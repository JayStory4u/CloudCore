//
//  CoreDataChangesListener.swift
//  CloudCore
//
//  Created by Vasily Ulianov on 02.02.17.
//  Copyright Â© 2017 Vasily Ulianov. All rights reserved.
//

import Foundation
import CoreData
import CloudKit

/// Class responsible for taking action on Core Data changes
class CoreDataObserver {
	var container: NSPersistentContainer
    var usePersistentHistory = false
	
	let converter = ObjectToRecordConverter()
	let pushOperationQueue = PushOperationQueue()

	let cloudContextName = "CloudCoreSync"
	
	// Used for errors delegation
	weak var delegate: CloudCoreDelegate?
	
	public init(container: NSPersistentContainer) {
		self.container = container
		converter.errorBlock = { [weak self] in
			self?.delegate?.error(error: $0, module: .some(.saveToCloud))
		}
        
        //usePersistentHistory = true
	}
	
	/// Observe Core Data willSave and didSave notifications
	func start() {
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(self.willSave(notification:)),
                                               name: .NSManagedObjectContextWillSave,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(self.didSave(notification:)),
                                               name: .NSManagedObjectContextDidSave,
                                               object: nil)
	}
	
	/// Remove Core Data observers
	func stop() {
		NotificationCenter.default.removeObserver(self)
	}
	
	deinit {
		stop()
	}
	
    func shouldProcess(_ context: NSManagedObjectContext) -> Bool {
        // Ignore saves that are generated by FetchAndSaveController
        if context.name != CloudCore.config.pushContextName { return false }
        
        // Upload only for changes in root context that will be saved to persistentStore
        if context.parent != nil { return false }
        
        return true
    }
    
    func processChanges() -> Bool {
        var success = true
        
        CloudCore.delegate?.willSyncToCloud()
        
        let backgroundContext = container.newBackgroundContext()
        backgroundContext.name = cloudContextName
        
        let records = converter.processPendingOperations(in: backgroundContext)
        pushOperationQueue.errorBlock = {
            self.handle(error: $0, parentContext: backgroundContext)
            success = false
        }
        pushOperationQueue.addOperations(recordsToSave: records.recordsToSave, recordIDsToDelete: records.recordIDsToDelete)
        pushOperationQueue.waitUntilAllOperationsAreFinished()
        
        if success {
            do {
                if backgroundContext.hasChanges {
                    try backgroundContext.save()
                }
            } catch {
                delegate?.error(error: error, module: .some(.saveToCloud))
                success = false
            }
        }
        
        CloudCore.delegate?.didSyncToCloud()
        
        return success
    }
        
	@objc private func willSave(notification: Notification) {
		guard let context = notification.object as? NSManagedObjectContext else { return }
        guard shouldProcess(context) else { return }
        
        if usePersistentHistory {
            context.insertedObjects.forEach { (inserted) in
                _ = try? inserted.setRecordInformation()
            }
        } else {
            converter.prepareOperationsFor(inserted: context.insertedObjects,
                                           updated: context.updatedObjects,
                                           deleted: context.deletedObjects)
        }
	}
	
	@objc private func didSave(notification: Notification) {
		guard let context = notification.object as? NSManagedObjectContext else { return }
        guard shouldProcess(context) else { return }
        
        if usePersistentHistory == true {
            DispatchQueue.main.async { [weak self] in
                guard let observer = self else { return }
                observer.processPersistentHistory()
            }
        } else {
            guard converter.hasPendingOperations else { return }
            
            DispatchQueue.global(qos: .utility).async { [weak self] in
                guard let observer = self else { return }
                _ = observer.processChanges()
            }
        }
	}
    
    func processPersistentHistory() {
        if #available(iOS 11.0, watchOSApplicationExtension 4.0, *) {
            container.performBackgroundTask { (moc) in
                let settings = UserDefaults.standard
                let key = "lastPersistentHistoryTokenKey"
                var token: NSPersistentHistoryToken? = nil
                if let data = settings.object(forKey: key) as? Data {
                     token = NSKeyedUnarchiver.unarchiveObject(with: data) as? NSPersistentHistoryToken
                }
                let historyRequest = NSPersistentHistoryChangeRequest.fetchHistory(after: token)
                do {
                    let historyResult = try moc.execute(historyRequest) as! NSPersistentHistoryResult
                    
                    if let history = historyResult.result as? [NSPersistentHistoryTransaction] {
                        for transaction in history {
                            if transaction.contextName != CloudCore.config.pushContextName { continue }
                            
                            if let changes = transaction.changes {
                                var insertedObjects = Set<NSManagedObject>()
                                var updatedObject = Set<NSManagedObject>()
                                var deletedRecordIDs: [RecordIDWithDatabase] = []
                                
                                for change in changes {
                                    switch change.changeType {
                                    case .insert:
                                        if let inserted = try? moc.existingObject(with: change.changedObjectID) {
                                            insertedObjects.insert(inserted)
                                        }
                                        
                                    case .update:
                                        if let inserted = try? moc.existingObject(with: change.changedObjectID) {
                                            updatedObject.insert(inserted)
                                        }
                                        
                                    case .delete:
                                        if change.tombstone != nil, let recordID = change.tombstone!["recordID"] as? String {
                                            let ckRecordID = CKRecord.ID(recordName: recordID, zoneID: CloudCore.config.zoneID)
                                            let recordIDWithDatabase = RecordIDWithDatabase(ckRecordID, CloudCore.config.container.privateCloudDatabase)
                                            deletedRecordIDs.append(recordIDWithDatabase)
                                        }
                                    }
                                }
                                
                                self.converter.prepareOperationsFor(inserted: insertedObjects,
                                                                    updated: updatedObject,
                                                                    deleted: deletedRecordIDs)

                                try? moc.save()

                                if self.converter.hasPendingOperations {                                    
                                    if self.processChanges() == true {
                                        let data = NSKeyedArchiver.archivedData(withRootObject: transaction.token)
                                        settings.set(data, forKey: key)
                                        
                                        NSPersistentHistoryChangeRequest.deleteHistory(before: transaction)
                                    } else {
                                        break
                                    }
                                }
                            }
                        }
                    }
                } catch {
                    let nserror = error as NSError
                    fatalError("Unresolved error \(nserror), \(nserror.userInfo)")
                }
            }
        }
    }
    
	private func handle(error: Error, parentContext: NSManagedObjectContext) {
		guard let cloudError = error as? CKError else {
			delegate?.error(error: error, module: .some(.saveToCloud))
			return
		}

		switch cloudError.code {
		// Zone was accidentally deleted (NOT PURGED), we need to reupload all data accroding Apple Guidelines
		case .zoneNotFound:
			pushOperationQueue.cancelAllOperations()
			
			// Create CloudCore Zone
			let createZoneOperation = CreateCloudCoreZoneOperation()
			createZoneOperation.errorBlock = {
				self.delegate?.error(error: $0, module: .some(.saveToCloud))
				self.pushOperationQueue.cancelAllOperations()
			}
			
			// Subscribe operation
			#if !os(watchOS)
				let subscribeOperation = SubscribeOperation()
				subscribeOperation.errorBlock = { self.delegate?.error(error: $0, module: .some(.saveToCloud)) }
				subscribeOperation.addDependency(createZoneOperation)
				pushOperationQueue.addOperation(subscribeOperation)
			#endif
			
			// Upload all local data
			let uploadOperation = PushAllLocalDataOperation(parentContext: parentContext, managedObjectModel: container.managedObjectModel)
			uploadOperation.errorBlock = { self.delegate?.error(error: $0, module: .some(.saveToCloud)) }
			
			pushOperationQueue.addOperations([createZoneOperation, uploadOperation], waitUntilFinished: true)
		case .operationCancelled: return
		default: delegate?.error(error: cloudError, module: .some(.saveToCloud))
		}
	}

}
