//
//  CoreDataChangesListener.swift
//  CloudCore
//
//  Created by Vasily Ulianov on 02.02.17.
//  Copyright Â© 2017 Vasily Ulianov. All rights reserved.
//

import Foundation
import CoreData
import CloudKit

/// Class responsible for taking action on Core Data save notifications
class CoreDataObserver {
	var container: NSPersistentContainer
	
	let converter = ObjectToRecordConverter()
	let pushOperationQueue = PushOperationQueue()

	let cloudContextName = "CloudCoreSync"
	
	// Used for errors delegation
	weak var delegate: CloudCoreDelegate?
	
	public init(container: NSPersistentContainer) {
		self.container = container
		converter.errorBlock = { [weak self] in
			self?.delegate?.error(error: $0, module: .some(.saveToCloud))
		}
	}
	
	/// Observe Core Data willSave and didSave notifications
	func start() {
		NotificationCenter.default.addObserver(self, selector: #selector(self.willSave(notification:)), name: .NSManagedObjectContextWillSave, object: nil)
		NotificationCenter.default.addObserver(self, selector: #selector(self.didSave(notification:)), name: .NSManagedObjectContextDidSave, object: nil)
	}
	
	/// Remove Core Data observers
	func stop() {
		NotificationCenter.default.removeObserver(self)
	}
	
	deinit {
		stop()
	}
	
    func shouldProcess(_ context: NSManagedObjectContext) -> Bool {
        // Ignore saves that are generated by FetchAndSaveController
        if context.name == CloudCore.config.contextName { return false }
        
        // Upload only for changes in root context that will be saved to persistentStore
        if context.parent != nil { return false }
        
        return true
    }
    
	@objc private func willSave(notification: Notification) {
		guard let context = notification.object as? NSManagedObjectContext else { return }
        guard shouldProcess(context) else { return }
        
		converter.prepareOperationsFor(inserted: context.insertedObjects,
		                                  updated: context.updatedObjects,
		                                  deleted: context.deletedObjects)
	}
	
	@objc private func didSave(notification: Notification) {
		guard let context = notification.object as? NSManagedObjectContext else { return }
        guard shouldProcess(context) else { return }
        guard converter.hasPendingOperations else { return }
        
		DispatchQueue.global(qos: .utility).async { [weak self] in
			guard let observer = self else { return }
			CloudCore.delegate?.willSyncToCloud()
			
			let backgroundContext = observer.container.newBackgroundContext()
			backgroundContext.name = observer.cloudContextName
			
			let records = observer.converter.processPendingOperations(in: backgroundContext)
			observer.pushOperationQueue.errorBlock = { observer.handle(error: $0, parentContext: backgroundContext) }
			observer.pushOperationQueue.addOperations(recordsToSave: records.recordsToSave, recordIDsToDelete: records.recordIDsToDelete)
			observer.pushOperationQueue.waitUntilAllOperationsAreFinished()
			
			do {
				if backgroundContext.hasChanges {
					try backgroundContext.save()
				}
			} catch {
				observer.delegate?.error(error: error, module: .some(.saveToCloud))
			}

			CloudCore.delegate?.didSyncToCloud()
		}
	}
	
	private func handle(error: Error, parentContext: NSManagedObjectContext) {
		guard let cloudError = error as? CKError else {
			delegate?.error(error: error, module: .some(.saveToCloud))
			return
		}

		switch cloudError.code {
		// Zone was accidentally deleted (NOT PURGED), we need to reupload all data accroding Apple Guidelines
		case .zoneNotFound:
			pushOperationQueue.cancelAllOperations()
			
			// Create CloudCore Zone
			let createZoneOperation = CreateCloudCoreZoneOperation()
			createZoneOperation.errorBlock = {
				self.delegate?.error(error: $0, module: .some(.saveToCloud))
				self.pushOperationQueue.cancelAllOperations()
			}
			
			// Subscribe operation
			#if !os(watchOS)
				let subscribeOperation = SubscribeOperation()
				subscribeOperation.errorBlock = { self.delegate?.error(error: $0, module: .some(.saveToCloud)) }
				subscribeOperation.addDependency(createZoneOperation)
				pushOperationQueue.addOperation(subscribeOperation)
			#endif
			
			// Upload all local data
			let uploadOperation = PushAllLocalDataOperation(parentContext: parentContext, managedObjectModel: container.managedObjectModel)
			uploadOperation.errorBlock = { self.delegate?.error(error: $0, module: .some(.saveToCloud)) }
			
			pushOperationQueue.addOperations([createZoneOperation, uploadOperation], waitUntilFinished: true)
		case .operationCancelled: return
		default: delegate?.error(error: cloudError, module: .some(.saveToCloud))
		}
	}

}
